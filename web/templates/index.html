<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PenDonn - Automated Penetration Testing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 0;
            border-bottom: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-left {
            flex: 1;
        }

        h1 {
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin: 0;
        }

        .subtitle {
            color: #a8d0ff;
            margin-top: 10px;
        }

        .service-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .service-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-right: 10px;
        }

        .btn-sm {
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #4affff;
        }

        .stat-label {
            font-size: 0.9em;
            color: #a8d0ff;
            margin-top: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            background: rgba(255,255,255,0.1);
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .tab.active {
            background: rgba(74,255,255,0.2);
            border-color: #4affff;
        }

        .content-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(255,255,255,0.2);
            display: none;
        }

        .content-panel.active {
            display: block;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(255,255,255,0.1);
            font-weight: bold;
        }

        tr:hover {
            background: rgba(255,255,255,0.05);
        }

        .btn {
            background: linear-gradient(135deg, #4affff 0%, #35d4d4 100%);
            color: #1e3c72;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4a4a 0%, #d43535 100%);
            color: #fff;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-success {
            background: #4affaa;
            color: #1e3c72;
        }

        .badge-warning {
            background: #ffaa4a;
            color: #1e3c72;
        }

        .badge-danger {
            background: #ff4a4a;
            color: #fff;
        }

        .badge-info {
            background: #4a9aff;
            color: #fff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running {
            background: #4affaa;
            box-shadow: 0 0 10px #4affaa;
        }

        .status-stopped {
            background: #ff4a4a;
        }

        .whitelist-form {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .whitelist-form input {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        .whitelist-form input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .network-list {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .network-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .network-item:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4affff;
            transform: translateX(5px);
        }

        .network-item-info {
            flex: 1;
        }

        .network-item-ssid {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .network-item-details {
            font-size: 0.9em;
            color: #a8d0ff;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #a8d0ff;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #a8d0ff;
        }

        .log-viewer {
            background: #0a1628;
            border-radius: 10px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .log-line {
            margin: 2px 0;
            word-wrap: break-word;
        }

        .log-error {
            color: #ff6b6b;
        }

        .log-warning {
            color: #ffd93d;
        }

        .log-info {
            color: #6bcf7f;
        }

        .log-debug {
            color: #a8d0ff;
        }

        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .log-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <h1>üîí PenDonn</h1>
                <p class="subtitle">Automated Penetration Testing System</p>
            </div>
            <div class="service-controls">
                <div class="service-status">
                    <span class="status-indicator" id="service-status-dot"></span>
                    <span id="service-status-text">Checking...</span>
                </div>
                <button class="btn btn-sm" onclick="controlService('start')" id="btn-start">‚ñ∂Ô∏è Start</button>
                <button class="btn btn-sm btn-danger" onclick="controlService('stop')" id="btn-stop">‚èπÔ∏è Stop</button>
                <button class="btn btn-sm" onclick="controlService('restart')" id="btn-restart">üîÑ Restart</button>
            </div>
        </header>

        <div class="dashboard" id="stats">
            <div class="stat-card">
                <div class="stat-value" id="stat-networks">-</div>
                <div class="stat-label">Networks Discovered</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-handshakes">-</div>
                <div class="stat-label">Handshakes Captured</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-passwords">-</div>
                <div class="stat-label">Passwords Cracked</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-vulns">-</div>
                <div class="stat-label">Vulnerabilities Found</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" onclick="refreshData()">üîÑ Refresh</button>
            <button class="btn" onclick="exportData()">üíæ Export Data</button>
            <button class="btn btn-danger" onclick="resetDatabase()">‚ö†Ô∏è Reset Database</button>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('networks')">Networks</div>
            <div class="tab" onclick="switchTab('handshakes')">Handshakes</div>
            <div class="tab" onclick="switchTab('passwords')">Passwords</div>
            <div class="tab" onclick="switchTab('scans')">Scans</div>
            <div class="tab" onclick="switchTab('vulnerabilities')">Vulnerabilities</div>
            <div class="tab" onclick="switchTab('whitelist')">Whitelist</div>
            <div class="tab" onclick="switchTab('logs')">üìã Logs</div>
        </div>

        <div id="networks-panel" class="content-panel active">
            <h2>Discovered Networks</h2>
            <div id="networks-content" class="loading">Loading...</div>
        </div>

        <div id="handshakes-panel" class="content-panel">
            <h2>Captured Handshakes</h2>
            <div id="handshakes-content" class="loading">Loading...</div>
        </div>

        <div id="passwords-panel" class="content-panel">
            <h2>Cracked Passwords</h2>
            <div id="passwords-content" class="loading">Loading...</div>
        </div>

        <div id="scans-panel" class="content-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Network Scans</h2>
                <button class="btn" onclick="exportPDFReport()" style="background: #e74c3c; color: white;">
                    üìÑ Export PDF Report
                </button>
            </div>
            <div id="scans-content" class="loading">Loading...</div>
        </div>

        <div id="vulnerabilities-panel" class="content-panel">
            <h2>Discovered Vulnerabilities</h2>
            <div id="vulnerabilities-content" class="loading">Loading...</div>
        </div>

        <div id="whitelist-panel" class="content-panel">
            <h2>SSID Whitelist</h2>
            <div class="whitelist-form">
                <input type="text" id="whitelist-input" placeholder="Enter SSID to whitelist...">
                <button class="btn" onclick="addToWhitelist()">Add to Whitelist</button>
                <button class="btn" onclick="showNetworkScanner()">üì° Scan Networks</button>
            </div>
            
            <div id="network-scanner" style="display: none; margin-bottom: 20px;">
                <h3>Available Networks (Tap to add to whitelist)</h3>
                <div id="scanned-networks" class="loading">Loading...</div>
            </div>
            
            <h3>Current Whitelist</h3>
            <div id="whitelist-content" class="loading">Loading...</div>
        </div>

        <div id="logs-panel" class="content-panel">
            <h2>System Logs</h2>
            <div class="log-controls">
                <button class="btn btn-sm" onclick="toggleLogStream()">
                    <span id="log-stream-btn-text">‚è∏ Pause</span>
                </button>
                <button class="btn btn-sm" onclick="clearLogs()">üóëÔ∏è Clear</button>
                <label>
                    <input type="checkbox" id="log-autoscroll" checked>
                    Auto-scroll
                </label>
                <label>
                    Lines: 
                    <select id="log-lines" onchange="reconnectLogStream()">
                        <option value="50">50</option>
                        <option value="100" selected>100</option>
                        <option value="200">200</option>
                        <option value="500">500</option>
                    </select>
                </label>
            </div>
            <div class="log-viewer" id="log-viewer"></div>
        </div>
    </div>

    <script>
        let currentTab = 'networks';
        let logEventSource = null;
        let logStreamActive = true;
        let maxLogLines = 500;

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            // Update panels
            document.querySelectorAll('.content-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(`${tab}-panel`).classList.add('active');

            currentTab = tab;
            loadTabData(tab);
        }

        function loadTabData(tab) {
            switch(tab) {
                case 'networks': loadNetworks(); break;
                case 'handshakes': loadHandshakes(); break;
                case 'passwords': loadPasswords(); break;
                case 'scans': loadScans(); break;
                case 'vulnerabilities': loadVulnerabilities(); break;
                case 'whitelist': loadWhitelist(); break;
                case 'logs': startLogStream(); break;
            }
        }

        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                if (data.success) {
                    const stats = data.status.statistics;
                    document.getElementById('stat-networks').textContent = stats.networks_discovered;
                    document.getElementById('stat-handshakes').textContent = stats.handshakes_captured;
                    document.getElementById('stat-passwords').textContent = stats.passwords_cracked;
                    document.getElementById('stat-vulns').textContent = stats.vulnerabilities_found;
                    
                    // Update service status
                    const statusDot = document.getElementById('service-status-dot');
                    const statusText = document.getElementById('service-status-text');
                    
                    if (data.status.daemon_running) {
                        statusDot.className = 'status-indicator status-running';
                        statusText.textContent = 'Running';
                    } else {
                        statusDot.className = 'status-indicator status-stopped';
                        statusText.textContent = 'Stopped';
                    }
                }
            } catch (error) {
                console.error('Error loading status:', error);
                const statusDot = document.getElementById('service-status-dot');
                const statusText = document.getElementById('service-status-text');
                statusDot.className = 'status-indicator status-stopped';
                statusText.textContent = 'Error';
            }
        }

        async function controlService(action) {
            if (!confirm(`Are you sure you want to ${action} the PenDonn service?`)) return;
            
            const btn = document.getElementById(`btn-${action}`);
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '‚è≥ Please wait...';
            
            try {
                const response = await fetch(`/api/service/${action}`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert(`Service ${action}ed successfully`);
                    setTimeout(loadStatus, 1000);
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error controlling service: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function startLogStream() {
            if (logEventSource) {
                logEventSource.close();
            }
            
            const lines = document.getElementById('log-lines').value;
            logEventSource = new EventSource(`/api/logs/stream?lines=${lines}`);
            logStreamActive = true;
            document.getElementById('log-stream-btn-text').textContent = '‚è∏ Pause';
            
            logEventSource.onmessage = function(event) {
                if (!logStreamActive) return;
                
                const logViewer = document.getElementById('log-viewer');
                const logLine = document.createElement('div');
                logLine.className = 'log-line';
                
                // Color code by log level
                const line = event.data;
                if (line.includes('ERROR')) {
                    logLine.className += ' log-error';
                } else if (line.includes('WARNING')) {
                    logLine.className += ' log-warning';
                } else if (line.includes('INFO')) {
                    logLine.className += ' log-info';
                } else if (line.includes('DEBUG')) {
                    logLine.className += ' log-debug';
                }
                
                logLine.textContent = line;
                logViewer.appendChild(logLine);
                
                // Limit number of lines
                while (logViewer.children.length > maxLogLines) {
                    logViewer.removeChild(logViewer.firstChild);
                }
                
                // Auto-scroll
                if (document.getElementById('log-autoscroll').checked) {
                    logViewer.scrollTop = logViewer.scrollHeight;
                }
            };
            
            logEventSource.onerror = function(error) {
                console.error('Log stream error:', error);
                const logViewer = document.getElementById('log-viewer');
                const errorLine = document.createElement('div');
                errorLine.className = 'log-line log-error';
                errorLine.textContent = '‚ùå Connection lost. Trying to reconnect...';
                logViewer.appendChild(errorLine);
            };
        }

        function toggleLogStream() {
            logStreamActive = !logStreamActive;
            const btn = document.getElementById('log-stream-btn-text');
            btn.textContent = logStreamActive ? '‚è∏ Pause' : '‚ñ∂Ô∏è Resume';
        }

        function reconnectLogStream() {
            if (logEventSource) {
                logEventSource.close();
            }
            clearLogs();
            startLogStream();
        }

        function clearLogs() {
            document.getElementById('log-viewer').innerHTML = '';
        }

        async function loadNetworks() {
            const content = document.getElementById('networks-content');
            try {
                const response = await fetch('/api/networks');
                const data = await response.json();
                
                if (data.success && data.networks.length > 0) {
                    let html = '<table><thead><tr><th>SSID</th><th>BSSID</th><th>Channel</th><th>Encryption</th><th>Signal</th><th>Last Seen</th><th>Whitelisted</th></tr></thead><tbody>';
                    
                    data.networks.forEach(net => {
                        const whitelistBadge = net.is_whitelisted ? 
                            '<span class="badge badge-info">Yes</span>' : 
                            '<span class="badge">No</span>';
                        
                        html += `<tr>
                            <td><strong>${net.ssid}</strong></td>
                            <td>${net.bssid}</td>
                            <td>${net.channel}</td>
                            <td>${net.encryption}</td>
                            <td>${net.signal_strength} dBm</td>
                            <td>${new Date(net.last_seen).toLocaleString()}</td>
                            <td>${whitelistBadge}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No networks discovered yet</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading networks</div>';
                console.error('Error:', error);
            }
        }

        async function loadHandshakes() {
            const content = document.getElementById('handshakes-content');
            try {
                const response = await fetch('/api/handshakes');
                const data = await response.json();
                
                if (data.success && data.handshakes.length > 0) {
                    let html = '<table><thead><tr><th>SSID</th><th>BSSID</th><th>Captured</th><th>Status</th><th>Quality</th></tr></thead><tbody>';
                    
                    data.handshakes.forEach(hs => {
                        let statusBadge = '';
                        if (hs.status === 'cracked') statusBadge = '<span class="badge badge-success">Cracked</span>';
                        else if (hs.status === 'cracking') statusBadge = '<span class="badge badge-warning">Cracking</span>';
                        else if (hs.status === 'pending') statusBadge = '<span class="badge badge-info">Pending</span>';
                        else statusBadge = '<span class="badge badge-danger">Failed</span>';
                        
                        html += `<tr>
                            <td><strong>${hs.ssid}</strong></td>
                            <td>${hs.bssid}</td>
                            <td>${new Date(hs.capture_date).toLocaleString()}</td>
                            <td>${statusBadge}</td>
                            <td>${hs.quality}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No handshakes captured yet</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading handshakes</div>';
                console.error('Error:', error);
            }
        }

        async function loadPasswords() {
            const content = document.getElementById('passwords-content');
            try {
                const response = await fetch('/api/passwords');
                const data = await response.json();
                
                if (data.success && data.passwords.length > 0) {
                    let html = '<table><thead><tr><th>SSID</th><th>BSSID</th><th>Password</th><th>Engine</th><th>Crack Time</th><th>Cracked</th></tr></thead><tbody>';
                    
                    data.passwords.forEach(pwd => {
                        const crackTime = pwd.crack_time_seconds < 60 ? 
                            `${pwd.crack_time_seconds}s` : 
                            `${Math.floor(pwd.crack_time_seconds / 60)}m ${pwd.crack_time_seconds % 60}s`;
                        
                        html += `<tr>
                            <td><strong>${pwd.ssid}</strong></td>
                            <td>${pwd.bssid}</td>
                            <td><code style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">${pwd.password}</code></td>
                            <td>${pwd.cracking_engine}</td>
                            <td>${crackTime}</td>
                            <td>${new Date(pwd.cracked_date).toLocaleString()}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No passwords cracked yet</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading passwords</div>';
                console.error('Error:', error);
            }
        }

        async function loadScans() {
            const content = document.getElementById('scans-content');
            try {
                const response = await fetch('/api/scans');
                const data = await response.json();
                
                if (data.success && data.scans.length > 0) {
                    let html = '<table><thead><tr><th></th><th>SSID</th><th>Scan Type</th><th>Status</th><th>Progress</th><th>Vulnerabilities</th><th>Started</th></tr></thead><tbody>';
                    
                    data.scans.forEach((scan, idx) => {
                        let statusBadge = '';
                        let progressInfo = '';
                        
                        if (scan.status === 'completed') {
                            statusBadge = '<span class="badge badge-success">‚úì Completed</span>';
                        } else if (scan.status === 'running') {
                            statusBadge = '<span class="badge badge-warning">‚ö° Running</span>';
                        } else {
                            statusBadge = '<span class="badge badge-danger">‚úó Failed</span>';
                        }
                        
                        // Parse results to show progress
                        let results = {};
                        try {
                            results = typeof scan.results === 'string' ? JSON.parse(scan.results) : scan.results;
                        } catch (e) {
                            results = scan.results || {};
                        }
                        
                        // Build progress summary
                        if (results.phases) {
                            let phases = [];
                            if (results.phases.connection?.status === 'success') phases.push('‚úì Connected');
                            else if (results.phases.connection?.status === 'failed') phases.push('‚úó Connection failed');
                            
                            if (results.phases.discovery) {
                                if (results.phases.discovery.status === 'completed') {
                                    phases.push(`‚úì ${results.phases.discovery.hosts_found || 0} hosts`);
                                } else if (results.phases.discovery.status === 'failed') {
                                    phases.push('‚úó Discovery failed');
                                }
                            }
                            
                            if (results.phases.port_scan) {
                                if (results.phases.port_scan.status === 'completed') {
                                    phases.push(`‚úì Scanned ${results.phases.port_scan.hosts_scanned || 0} hosts`);
                                } else if (results.phases.port_scan.status === 'failed') {
                                    phases.push('‚úó Scan failed');
                                }
                            }
                            
                            if (results.phases.plugins) {
                                if (results.phases.plugins.status === 'completed') {
                                    phases.push('‚úì Plugins completed');
                                } else if (results.phases.plugins.status === 'failed') {
                                    phases.push('‚úó Plugins failed');
                                }
                            }
                            
                            progressInfo = phases.join(' ‚Üí ') || 'No data';
                        } else if (results.error) {
                            progressInfo = `<span class="text-danger">Error: ${results.error}</span>`;
                        }
                        
                        const expandId = `scan-details-${idx}`;
                        html += `<tr onclick="toggleScanDetails('${expandId}')" style="cursor: pointer;">
                            <td><span id="${expandId}-icon">‚ñ∂</span></td>
                            <td><strong>${scan.ssid}</strong></td>
                            <td>${scan.scan_type}</td>
                            <td>${statusBadge}</td>
                            <td style="font-size: 0.85em;">${progressInfo}</td>
                            <td><span class="badge badge-danger">${scan.vulnerabilities_found}</span></td>
                            <td>${new Date(scan.start_time).toLocaleString()}</td>
                        </tr>`;
                        
                        // Expandable details row
                        html += `<tr id="${expandId}" class="scan-details-row" style="display: none;">
                            <td colspan="7">
                                <div style="padding: 15px; background: #f8f9fa; border-left: 3px solid #007bff;">`;
                        
                        // Show detailed phase information
                        if (results.phases) {
                            html += '<h4 style="margin-top: 0;">Enumeration Phases:</h4>';
                            
                            // Connection phase
                            if (results.phases.connection) {
                                const conn = results.phases.connection;
                                html += `<div style="margin-bottom: 10px;"><strong>Phase 1: Connection</strong> - `;
                                if (conn.status === 'success') {
                                    html += '<span class="badge badge-success">Success</span>';
                                } else {
                                    html += `<span class="badge badge-danger">Failed</span>`;
                                    if (conn.error) html += `<br><span class="text-danger">Error: ${conn.error}</span>`;
                                }
                                html += '</div>';
                            }
                            
                            // Discovery phase
                            if (results.phases.discovery) {
                                const disc = results.phases.discovery;
                                html += `<div style="margin-bottom: 10px;"><strong>Phase 2: Host Discovery</strong> - `;
                                if (disc.status === 'completed') {
                                    html += `<span class="badge badge-success">Found ${disc.hosts_found || 0} hosts</span>`;
                                } else {
                                    html += `<span class="badge badge-danger">Failed</span>`;
                                    if (disc.error) html += `<br><span class="text-danger">Error: ${disc.error}</span>`;
                                }
                                html += '</div>';
                            }
                            
                            // Port scan phase
                            if (results.phases.port_scan) {
                                const ports = results.phases.port_scan;
                                html += `<div style="margin-bottom: 10px;"><strong>Phase 3: Port Scanning</strong> - `;
                                if (ports.status === 'completed') {
                                    html += `<span class="badge badge-success">Scanned ${ports.hosts_scanned || 0} hosts</span>`;
                                    
                                    // Show host details if available
                                    if (ports.results && ports.results.length > 0) {
                                        html += '<div style="margin-top: 10px; margin-left: 20px;">';
                                        ports.results.forEach(host => {
                                            html += `<div style="margin-bottom: 8px;">
                                                <strong>${host.ip}</strong> ${host.hostname ? `(${host.hostname})` : ''}
                                                ${host.os ? `<br>OS: ${host.os}` : ''}`;
                                            if (host.ports && host.ports.length > 0) {
                                                html += '<br>Open ports: ';
                                                html += host.ports.map(p => `${p.port}/${p.service || 'unknown'}`).join(', ');
                                            }
                                            html += '</div>';
                                        });
                                        html += '</div>';
                                    }
                                } else {
                                    html += `<span class="badge badge-danger">Failed</span>`;
                                    if (ports.error) html += `<br><span class="text-danger">Error: ${ports.error}</span>`;
                                }
                                html += '</div>';
                            }
                            
                            // Plugins phase
                            if (results.phases.plugins) {
                                const plugins = results.phases.plugins;
                                html += `<div style="margin-bottom: 10px;"><strong>Phase 4: Vulnerability Plugins</strong> - `;
                                if (plugins.status === 'completed') {
                                    html += `<span class="badge badge-success">Found ${plugins.vulnerabilities_found || 0} vulnerabilities</span>`;
                                } else {
                                    html += `<span class="badge badge-danger">Failed</span>`;
                                    if (plugins.error) html += `<br><span class="text-danger">Error: ${plugins.error}</span>`;
                                }
                                html += '</div>';
                            }
                        } else if (results.error) {
                            html += `<h4 style="margin-top: 0; color: #dc3545;">Error</h4>`;
                            html += `<p><strong>Error Type:</strong> ${results.error_type || 'Unknown'}</p>`;
                            html += `<p><strong>Message:</strong> ${results.error}</p>`;
                        } else {
                            html += '<p>No detailed information available</p>';
                        }
                        
                        html += `</div></td></tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                    
                    // Restore expanded state after refresh
                    expandedScans.forEach(id => {
                        const detailsRow = document.getElementById(id);
                        const icon = document.getElementById(id + '-icon');
                        if (detailsRow && icon) {
                            detailsRow.style.display = 'table-row';
                            icon.textContent = '‚ñº';
                        }
                    });
                } else {
                    content.innerHTML = '<div class="empty-state">No scans performed yet</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading scans</div>';
                console.error('Error:', error);
            }
        }
        
        // Track which scan details are expanded
        const expandedScans = new Set();
        
        function toggleScanDetails(id) {
            const detailsRow = document.getElementById(id);
            const icon = document.getElementById(id + '-icon');
            if (detailsRow.style.display === 'none') {
                detailsRow.style.display = 'table-row';
                icon.textContent = '‚ñº';
                expandedScans.add(id);  // Remember this is expanded
            } else {
                detailsRow.style.display = 'none';
                icon.textContent = '‚ñ∂';
                expandedScans.delete(id);  // Remember this is collapsed
            }
        }

        async function exportPDFReport(scanId = null) {
            try {
                // Show loading indicator
                const btn = event.target;
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚è≥ Generating PDF...';
                btn.disabled = true;

                // Build URL with scan_id parameter if provided
                let url = '/api/export/pdf';
                if (scanId) {
                    url += `?scan_id=${scanId}`;
                }

                // Fetch the PDF
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error('Failed to generate PDF report');
                }

                // Get the PDF blob
                const blob = await response.blob();
                
                // Create a download link
                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = downloadUrl;
                
                // Extract filename from response headers or use default
                const contentDisposition = response.headers.get('content-disposition');
                const filename = contentDisposition 
                    ? contentDisposition.split('filename=')[1].replace(/"/g, '')
                    : `pendonn_report_${new Date().getTime()}.pdf`;
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                window.URL.revokeObjectURL(downloadUrl);
                document.body.removeChild(a);
                
                // Reset button
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                showNotification('PDF report downloaded successfully', 'success');
            } catch (error) {
                console.error('PDF export error:', error);
                showNotification('Failed to export PDF report', 'error');
                
                // Reset button on error
                if (event && event.target) {
                    event.target.innerHTML = 'üìÑ Export PDF Report';
                    event.target.disabled = false;
                }
            }
        }

        async function loadVulnerabilities() {
            const content = document.getElementById('vulnerabilities-content');
            try {
                const response = await fetch('/api/vulnerabilities');
                const data = await response.json();
                
                if (data.success && data.vulnerabilities.length > 0) {
                    let html = '<table><thead><tr><th>Host</th><th>Port</th><th>Service</th><th>Type</th><th>Severity</th><th>Description</th><th>Plugin</th></tr></thead><tbody>';
                    
                    data.vulnerabilities.forEach(vuln => {
                        let severityBadge = '';
                        if (vuln.severity === 'critical') severityBadge = '<span class="badge badge-danger">Critical</span>';
                        else if (vuln.severity === 'high') severityBadge = '<span class="badge badge-danger">High</span>';
                        else if (vuln.severity === 'medium') severityBadge = '<span class="badge badge-warning">Medium</span>';
                        else severityBadge = '<span class="badge badge-info">Low</span>';
                        
                        html += `<tr>
                            <td><strong>${vuln.host}</strong></td>
                            <td>${vuln.port || 'N/A'}</td>
                            <td>${vuln.service || 'N/A'}</td>
                            <td>${vuln.vulnerability_type}</td>
                            <td>${severityBadge}</td>
                            <td>${vuln.description}</td>
                            <td>${vuln.plugin_name}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No vulnerabilities found yet</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading vulnerabilities</div>';
                console.error('Error:', error);
            }
        }

        async function loadWhitelist() {
            const content = document.getElementById('whitelist-content');
            try {
                const response = await fetch('/api/whitelist');
                const data = await response.json();
                
                if (data.success && data.whitelist.length > 0) {
                    let html = '<table><thead><tr><th>SSID</th><th>Action</th></tr></thead><tbody>';
                    
                    data.whitelist.forEach(ssid => {
                        html += `<tr>
                            <td><strong>${ssid}</strong></td>
                            <td><button class="btn btn-danger" onclick="removeFromWhitelist('${ssid}')">Remove</button></td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No SSIDs in whitelist</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error loading whitelist</div>';
                console.error('Error:', error);
            }
        }

        async function addToWhitelist() {
            const input = document.getElementById('whitelist-input');
            const ssid = input.value.trim();
            
            if (!ssid) {
                alert('Please enter an SSID');
                return;
            }
            
            try {
                const response = await fetch('/api/whitelist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ssid })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    input.value = '';
                    loadWhitelist();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error adding to whitelist');
                console.error('Error:', error);
            }
        }

        async function removeFromWhitelist(ssid) {
            if (!confirm(`Remove ${ssid} from whitelist?`)) return;
            
            try {
                const response = await fetch(`/api/whitelist/${encodeURIComponent(ssid)}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    loadWhitelist();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error removing from whitelist');
                console.error('Error:', error);
            }
        }

        async function showNetworkScanner() {
            const scanner = document.getElementById('network-scanner');
            const content = document.getElementById('scanned-networks');
            
            // Toggle visibility
            if (scanner.style.display === 'none') {
                scanner.style.display = 'block';
                content.innerHTML = '<div class="loading">Scanning for networks...</div>';
                await loadAvailableNetworks();
            } else {
                scanner.style.display = 'none';
            }
        }

        async function loadAvailableNetworks() {
            const content = document.getElementById('scanned-networks');
            try {
                const response = await fetch('/api/networks?recent_only=true');
                const data = await response.json();
                
                if (data.success && data.networks.length > 0) {
                    let html = '<div class="network-list">';
                    
                    data.networks.forEach(net => {
                        const inWhitelist = net.is_whitelisted ? ' ‚úì In Whitelist' : '';
                        html += `<div class="network-item" onclick="addNetworkToWhitelist('${net.ssid}')">
                            <div class="network-item-info">
                                <div class="network-item-ssid">${net.ssid}${inWhitelist}</div>
                                <div class="network-item-details">
                                    ${net.encryption} ‚Ä¢ Channel ${net.channel} ‚Ä¢ ${net.signal_strength} dBm
                                </div>
                            </div>
                            <div>‚ûï</div>
                        </div>`;
                    });
                    
                    html += '</div>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = '<div class="empty-state">No networks found nearby</div>';
                }
            } catch (error) {
                content.innerHTML = '<div class="empty-state">Error scanning networks</div>';
                console.error('Error:', error);
            }
        }

        async function addNetworkToWhitelist(ssid) {
            try {
                const response = await fetch('/api/whitelist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ssid })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    loadWhitelist();
                    loadAvailableNetworks(); // Refresh to show updated status
                    alert(`‚úì ${ssid} added to whitelist`);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error adding to whitelist');
                console.error('Error:', error);
            }
        }

        async function exportData() {
            try {
                const response = await fetch('/api/export', { method: 'POST' });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pendonn_export_${new Date().getTime()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    alert('Error exporting data');
                }
            } catch (error) {
                alert('Error exporting data');
                console.error('Error:', error);
            }
        }

        async function resetDatabase() {
            if (!confirm('Are you sure? This will delete all data and files (a backup will be created).')) return;
            if (!confirm('FINAL WARNING: This action cannot be undone! Service will need restart.')) return;
            
            try {
                const response = await fetch('/api/database/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keep_backup: true, clean_files: true })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Database reset successfully! IMPORTANT: Please restart the PenDonn service:\nsudo systemctl restart pendonn.service');
                    refreshData();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error resetting database');
                console.error('Error:', error);
            }
        }

        function refreshData() {
            loadStatus();
            loadTabData(currentTab);
        }

        // Initialize
        loadStatus();
        loadNetworks();

        // Auto-refresh every 3 seconds for responsive UI
        setInterval(refreshData, 3000);
    </script>
</body>
</html>
